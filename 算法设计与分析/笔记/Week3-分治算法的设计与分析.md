# 分治算法的设计与分析

## 00 内容简介

1、分治算法的设计思想举例：

二分检索、二分归并排序、Hanoi塔

2、分治算法的一般描述，分治算法的分析方法

3、三个例子：芯片测试、幂乘算法、快速排序

4、分治算法改进途径：减少子问题的个数，预处理

## 01 分治策略的设计思想

1、分治策略（Divide and Conquer）
将原始问题划分或者归结为规模较小的子问题；递归或迭代求解每个子问题；将子问题的解综合得到原问题的解。

**注意**：子问题与原问题性质完全一样；子问题之间可彼此独立地求解；递归停止时子问题可直接求解。算法可以递归也可以迭代实现；算法的分析方法：递推方程。

2、二分检索

算法 Binary Search (T, l, r, x) 

输入:数组 T，下标从 l 到 r;数 x 

输出:j // 若x在T 中, j 为下标; 否则为 0

通过 x 与中位数的比较，将原问题归结 为规模减半的子问题，如果 x 小于中位 数，则子问题由小于 x 的数构成，否则 子问题由大于 x 的数构成.

二分检索问题时间复杂度W(n)=[logn] + 1 

3、二分归并排序

划分将原问题归结为规模为n/2的 2 个子问题

继续划分，将原问题归结为规模为 n/4 的 4 个子问题. 继续...，当子问 题规模为1 时，划分结束.

从规模1到n/2，陆续归并被排好序的两个子数组. 每归并一次，数组规模扩大一倍，直到原始数组.

二分归并问题时间复杂度W(n)=nlogn - n + 1

## 02 分治算法的一般描述和分析方法

1、划分--独立求解子问题--综合解

2、分治算法时间分析

划分子问题工作量+将子问题的解综合得到原问题解的总工作量

3、递推方程

![image-20221221210023506](/Users/yuxing/Library/Application Support/typora-user-images/image-20221221210023506.png)

求解方法

方程1:迭代法、递归树

方程2:迭代法、换元法、递归树、主定理

4、一般描述：划分或归约为彼此独立的子问题；分别求解每个子问题；给出递归或迭代计算的终止条件；如何由子问题的解得到原问题的解

5、分析方法：求解时间复杂度的递推方程；常用的递推方程的解。

## 03 芯片测试

1、AB芯片互相测试，好芯片的报告一定正确，坏芯片的报告不确定。

AB都好说明都好或都坏；其他情况说明至少一片是坏的

2、问题

输入：n片芯片，其中好芯片至少比坏芯片多一篇

问题：设计一种测试方法，通过测试从n片芯片中挑出1片好芯片。

要求：使用最少的测试次数。

3、划分--给定芯片A，判定A的好坏。

![image-20221221211236051](https://raw.githubusercontent.com/JiuZhouu/ImageBed/main/mac/202212212112856.png)

<img src="https://raw.githubusercontent.com/JiuZhouu/ImageBed/main/mac/202212212114563.png" alt="image-20221221211251767" style="zoom: 33%;" />

4、蛮力算法：任取一片芯片测试，直到得到好芯片。时间估计：

$\theta (n^2)$ 

5、分治算法：假设n为偶数，两两一组测试，--下一轮分组淘汰

好好->任留一片，进入下轮；其他情况全部抛弃

3片芯片，一次测试得到好芯片；1片或2片不用测试。

当n为奇数时，增加一轮对轮空芯片的单独测试。

时间复杂度：$O(n)$

6、芯片测试的分治算法

如何保证子问题与原问题性质相同：增加额外处理；

额外处理的工作量不改变函数的阶

## 04 快速排序

1、基本思想：用首元素 x 作划分标准，将输入数组 A划分成不超过 x 的元素构成的数组 $A_L$，大于 x 的元素构成的数组$A_R$. 其中$ A_L$,$ A_R$从左到右存放在数组 A 的位置.

递归地对子问题 $A_L$和$ A_R $进行排序， 直到子问题规模为 1 时停止.

2、时间复杂度

最坏情况$ W(n)=n(n-1)/2$

最好情况$ T(n)=\theta(nlogn)$

3、快速排序算法小结

分治策略

子问题划分由首元素决定

最坏情况下时间$O(n^2)$

平均情况下时间$O(nlogn)$

## 05 幂乘算法及应用

1、幂乘问题：

输入: a为给定实数，n为自然数

输出: $a^n$

传统算法: 顺序相乘 $an = (...(((a a)a)a)...)a$

乘法次数: $\theta(n)$

2、分治算法划分，以乘法作为基本运算。

![image-20221221223549528](https://raw.githubusercontent.com/JiuZhouu/ImageBed/main/mac/202212212236689.png)

3、幂乘算法的应用：算斐波那契数列

通常算法$O(n)$，分治算法$O(logn)$

## 06 改进分治算法的途径1:减少子问题数

1、利用子问题的依赖关系，使某些子问题的解通过组合其他子问题的解而得到。

eg拆分代数变换，矩阵分块

2、矩阵乘法的研究及应用

![image-20221221230620427](https://raw.githubusercontent.com/JiuZhouu/ImageBed/main/mac/202212212306626.png)

3、综合解的工作量可能会增加，但增加的工作量不影响W(n)的阶。



## 07 改进分治算法的途径2:增加预处理

1、eg平面点对问题

n个点中，输出两个距离最小的点

分治策略：划分为子集，比较最近点对，比较子集中各一个点的最近点对

2、增加预处理

原算法：在每次划分时对子问题数组重新排序

改进算法：

（1）在递归前对XY排序，作为预处理；

（2）划分时对排序的数组XY进行拆分，得到针对子问题PL的数组XLYL以及针对子问题PR的数组XR、YR

拆分时间为O(n)

![image-20221221232445018](https://raw.githubusercontent.com/JiuZhouu/ImageBed/main/mac/202212212324863.png)

3、小结

![image-20221221232536812](https://raw.githubusercontent.com/JiuZhouu/ImageBed/main/mac/202212212325311.png)
